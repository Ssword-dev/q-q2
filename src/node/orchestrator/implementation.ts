import express, { RequestHandler } from "express";

// types for express packages.
import type * as ServeProxy from "http-proxy-middleware";

import type * as ServeStatic from "serve-static";
// vite
import type * as Vite from "vite";

// chokidar
import { FSWatcher, watch as createWatcher, FSWatcherEventMap } from "chokidar";

// http
import { Server } from "node:http";

// sub-processing
import {
  spawn,
  ChildProcess,
  SpawnOptionsWithoutStdio,
  SpawnOptions,
} from "node:child_process";
import EventEmitter from "node:events";
import { createLazyLoader } from "./loaders";
import lazyImport from "./loader";
import ServiceBuilder from "./builders/service-builder";
import WatcherBuilder from "./builders/watcher-builder";
import loader from "./loader";
import Service from "./service";
import { AppBase, ExpressForwardMethods, Applyable } from "./types";
import ProcessBuilder from "./builders/process-builder";

/**
 * # App
 *
 * An app is a wrapper of `express.Express` that may or may
 * not define behaviours depending on the current environment.
 *
 * ## Purpose
 *
 * An app is a special entity that orchestrates common CL features
 * such as servers, subprocesses, services, and more.
 *
 * ## Sequential Initiation
 *
 * App initiation is ***sequential*** by design, the app uses
 * a linked-list style of execution by chaining ***promises***
 * via the `_last_promise_1` internal property.
 *
 * ## Subprocess, Service, and Watcher Termination.
 *
 * Any ***subprocess*** started via the API method `addSubprocess`,
 * any ***service*** started via the API method `addService`,
 * and any ***watcher*** started via the API method `addWatcher`
 * will be killed **before** the app's termination.
 *
 * ## Builders
 *
 * Any ***builder*** object generated by API methods must be finalized to
 * take effect.
 */
class AppInstance
  extends EventEmitter
  implements AppBase, ExpressForwardMethods
{
  public _express: express.Express;
  public _server: Server | null;
  public _watchers: FSWatcher[];
  public _sub_processes: ChildProcess[];
  public _services: Service[];
  public _last_promise_1: Promise<any> | null;
  /**
   * @inheritdoc
   */
  constructor() {
    super();
    this._express = express();
    this._watchers = [];
    this._sub_processes = [];
    this._services = [];
    this._server = null;
    this._last_promise_1 = null;
  }

  listen(...args: any[]) {
    this.enterCritical(async () => {
      this._server = this._express.listen(...args);
    });

    return this;
  }

  async dispose() {
    if (!this._server) {
      throw new Error("Please call .listen before .dispose!");
    }

    await new Promise<void>((resolve, reject) => {
      if (!this._server) return resolve();
      this._server.close(err => (err ? reject(err) : resolve()));
    });

    for (const w of this._watchers) {
      await w.close();
    }

    for (const sp of this._sub_processes) {
      if (sp.killed) continue;
      sp.kill("SIGTERM");
    }

    for (const s of this._services) {
      await s.dispose();
      console.log(`Disposed ${s.name}`);
    }

    process.exit(0);
  }

  /**
   * @param route The route to take proxy request from.
   * @param options The options for the proxy.
   * @returns everything returns this or a builder. except dispose.
   * or other future methods.
   */
  proxy(route: string, options: ServeProxy.Options) {
    this.enterCritical(async () => {
      const { value: modulePromise } = loader<
        typeof import("http-proxy-middleware")
      >("http-proxy-middleware");
      const { createProxyMiddleware } = await modulePromise;
      this._express.use(route, createProxyMiddleware(options));
    });
    return this;
  }

  static(
    route: string,
    root: string,
    options?: ServeStatic.ServeStaticOptions
  ) {
    this.enterCritical(async () => {
      this._express.use(route, express.static(root, options));
    });
    return this;
  }

  /**
   * @param paths The paths of files and folders to watch.
   * @param options The options for the watcher.
   * @returns a watcher builder that can be used for configuring
   * the watcher further.
   */
  addWatcher(
    paths: string | string[],
    options: Parameters<typeof createWatcher>[1]
  ) {
    return new WatcherBuilder(this, paths, options);
  }

  /**
   * @param service The name of the service.
   * @returns a service builder that can be used for configuring
   * the service.
   */
  addService(service: string) {
    return new ServiceBuilder<this>(this, service);
  }

  /**
   * @param executable The command /path to the executable, preferably
   * absolute paths.
   * @param args The argument values, or argv in C / C++ and other languages.
   * @returns A subprocess builder that can be used to configure the subprocess further.
   */
  addSubprocess(executable: string, args: string[]) {
    return new ProcessBuilder<AppInstance>(this, executable, args);
  }

  /**
   * @param opts The options for vite.
   * @returns also returns `this`.
   */
  addVite(
    opts: Partial<Omit<Vite.InlineConfig & Vite.ResolvedConfig, "server">>
  ) {
    this.enterCritical(async () => {
      const { value: viteModulePromise } =
        loader<typeof import("vite")>("vite");
      const { createServer: createViteServer } = await viteModulePromise;

      const vite_promise = createViteServer({
        ...opts,
        server: {
          middlewareMode: true,
        },
      });
      const vite = await vite_promise;
      vite.bindCLIShortcuts();
      this._express.use(vite.middlewares);
    });

    return this;
  }

  // utilities

  /**
   * @param cb Action to run when development.
   * @returns also returns `this`.
   */
  ifDev(cb: Applyable<this>) {
    if (process.env.NODE_ENV === "development") {
      cb(this);
    }
    return this;
  }

  /**
   * @param cb Action to run on production.
   * @returns also returns `this`.
   */
  ifProd(cb: Applyable<this>) {
    if (process.env.NODE_ENV === "production") {
      cb(this);
    }

    return this;
  }

  /**
   * @param cb Function to apply to app.
   * @returns also returns `this`.
   */
  apply(cb: Applyable<this>) {
    cb(this);
    return this;
  }

  /**
   * Binds the lifecycle of the app to actual process lifecycle.
   * @returns also returns this.
   */
  bindLifecycle() {
    const arrow = this.dispose.bind(this);

    process.on("SIGINT", arrow).on("SIGTERM", arrow);
    return this;
  }

  /**
   * An internal method for entering asyncronous operations.
   * @param cb async callback to run sequentially.
   */
  public enterCritical(cb: () => Promise<any>) {
    if (this._last_promise_1) {
      this._last_promise_1.then(() => (this._last_promise_1 = cb()));
    } else {
      this._last_promise_1 = cb();
    }
  }

  /**
   * @returns The last promise or a resolved null promise.
   */
  async promise() {
    return this._last_promise_1 ? this._last_promise_1 : Promise.resolve(null);
  }

  // forward calls.
  public use(route: string, ...handlers: express.RequestHandler[]) {
    this._express.use(route, ...handlers);
    return this;
  }

  public get(route: string, ...handlers: express.RequestHandler[]) {
    this._express.get(route, ...handlers);
    return this;
  }

  public put(route: string, ...handlers: express.RequestHandler[]) {
    this._express.put(route, ...handlers);
    return this;
  }

  public post(route: string, ...handlers: express.RequestHandler[]) {
    this._express.post(route, ...handlers);
    return this;
  }

  public delete(route: string, ...handlers: express.RequestHandler[]) {
    this._express.delete(route, ...handlers);
    return this;
  }

  public patch(route: string, ...handlers: express.RequestHandler[]) {
    this._express.patch(route, ...handlers);
    return this;
  }

  public options(route: string, ...handlers: express.RequestHandler[]) {
    this._express.options(route, ...handlers);
    return this;
  }

  public head(route: string, ...handlers: express.RequestHandler[]) {
    this._express.head(route, ...handlers);
    return this;
  }

  // upgrades / evolution

  express() {
    return this; // this is already express compatible.
  }
}

export default AppInstance;
